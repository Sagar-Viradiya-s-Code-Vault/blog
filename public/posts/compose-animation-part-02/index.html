<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Compose Animation, Under The Hood - Part II | Sagar's Blog</title>
<meta name=keywords content="Compose,Animation"><meta name=description content="A deep dive on Animatable API."><meta name=author content><link rel=canonical href=https://sagarviradiya.dev/posts/compose-animation-part-02/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.083b73ab99f7bb76228f3b506c8b579236a3f308e4021b0c281be819e5d67681.css integrity="sha256-CDtzq5n3u3YijztQbItXkjaj8wjkAhsMKBvoGeXWdoE=" rel="preload stylesheet" as=style><link rel=icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sagarviradiya.dev/posts/compose-animation-part-02/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://sagarviradiya.dev/posts/compose-animation-part-02/"><meta property="og:site_name" content="Sagar's Blog"><meta property="og:title" content="Compose Animation, Under The Hood - Part II"><meta property="og:description" content="A deep dive on Animatable API."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-30T00:00:00+00:00"><meta property="article:tag" content="Compose"><meta property="article:tag" content="Animation"><meta property="og:image" content="https://sagarviradiya.dev/images/header.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sagarviradiya.dev/images/header.jpeg"><meta name=twitter:title content="Compose Animation, Under The Hood - Part II"><meta name=twitter:description content="A deep dive on Animatable API."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sagarviradiya.dev/posts/"},{"@type":"ListItem","position":2,"name":"Compose Animation, Under The Hood - Part II","item":"https://sagarviradiya.dev/posts/compose-animation-part-02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Compose Animation, Under The Hood - Part II","name":"Compose Animation, Under The Hood - Part II","description":"A deep dive on Animatable API.","keywords":["Compose","Animation"],"articleBody":"Context In Part-I, I explained how the Compose animation system leverages the low-level animation API to calculate the animation value for a given frame (playtime of animation). If you haven‚Äôt read that I would highly recommend reading that first before continuing here.\nThings will get interesting in this part as we will explore how the Compose Animation system was built on top of Animation API. We will see how Animation API we saw in Part I gets consumed by Compose‚Äôs Animatable API.\nAnimatable Animatable is the stateful API. This means it has a Composable state wrapped in it that gets updated periodically for the duration of the animation. The state value exposed by Animatable is something end users use within Composable. Since Compose recomposes on every state change, the value exposed by Animatable causes rapid change in UI resulting in animation.\nThis API also keeps track of the progress of the animation. It knows where animation has reached based on the time passed since animation started and the duration of animation provided by the user.\nThe real beauty of this API is coroutine. Calling animateTo function causes thread suspension until it finishes the animation. This unlocks the possibility of running multiple animations parallelly or sequentially. Here is the cool animation that I found on Lottie and reimplemented in Compose.\nYour browser does not support the video tag. If you want to check implementation of above animation and more such sample animations then check out my open-source project koreography.\nWith this basic context on API, let‚Äôs quickly see the code sample to know how you can consume this API.\n// Compose scope val isVisible by remember { mutableStateOf(false) } val alphaAnimatable = remember { Animatable(0f) } LaunchedEffect(isVisible) { // Coroutine Scope alphaAnimatable.animateTo(if (isVisible) 1f else 0f) // Suspend function } Image( modifier = Modifier.graphicsLayer { alpha = alphaAnimatable.value }, painter = painterResource(id = R.drawable.image), contentDescription = \"Image\" ) Here we are triggering alpha animation on isVisible state change. Within launched effect, we call animateTo on alphaAnimatable. This will cause alpha to be animated towards 0 or 1 based on the isVisible state.\nNotice how we are consuming alpha value exposed by Animatable within Image composable. The alphaAnimatable.value is essentially the value of the state wrapped in Animatable.\nNothing complicated here, this is just a Composable going through multiple recompositions (or relayout and redraw since we are using graphics layer API in the example to consume state) for a fixed duration of Animation. But how does this state changes happens?\nLet‚Äôs understand this with the following visuals.\nYour browser does not support the video tag. Animatable wraps three things within. Animation, State, and FrameListner.\nFrameListener listens for the frames. When the next frame is ready to render, it gets a callback with frame time in nanoseconds. Animatable then calculates the playtime of animation. By simply subtracting the first frame time (when the animation starts it stores the frame time) from the current frame time. This playtime is then fed to Animation API. In Part I, we saw Animation API is a function of time. It accepts the playtime and calculates the value of animation at that particular playtime. Animation API then outputs the calculated value. The calculated value is then applied to the state. The above 4 steps happen for each frame for the duration of Animation. Syncing with the system frame plays a crucial role here in keeping track of the progress of animation as well as calculating playtime.\nAlright, that‚Äôs all on the theory behind Animatable API. Let‚Äôs see the above four steps in terms of the implementation perspective. Let‚Äôs start with the entry point, the animateTo function call from the example earlier.\nFor the scope of this blog, I am only covering target-based animation. I will leave decay-based animation up to you to explore. Hopefully, it will be easier to explore after reading this blog.\nanimateTo üßê suspend fun animateTo( targetValue: T, animationSpec: AnimationSpec\u003cT\u003e = defaultSpringSpec, initialVelocity: T = velocity, block: (Animatable\u003cT, V\u003e.() -\u003e Unit)? = null ): AnimationResult\u003cT, V\u003e { val anim = TargetBasedAnimation( animationSpec = animationSpec, initialValue = value, targetValue = targetValue, typeConverter = typeConverter, initialVelocity = initialVelocity ) return runAnimation(anim, initialVelocity, block) } If we see the implementation of animateTo function, all it does is create TargetBasedAnimation passing AnimationSpec, target value, and other params. It then kicks in animation calling the internal function runAnimation passing newly created Animation and other params.\nAlright, Let‚Äôs dig further and see where calling runAnimation leads.\n. . . while (lateInitScope!!.isRunning) { val durationScale = coroutineContext.durationScale animation.callWithFrameNanos { frameTimeInNano -\u003e lateInitScope!!.doAnimationFrameWithScale( frameTimeInNano, durationScale, animation, this, block ) } } . . . For simplicity, I trim down code to focus on important things.\nRemember I mentioned earlier?, the four steps we saw keep repeating for each frame for the duration of the Animation. Well, above while loop takes care of that.\nThe lateInitScope is of type AnimationScope. AnimationScope is a class that provides all the animation related info specific to an animation run. Wrapping many things such as if animation is in progress (isRunning check in while loop above), current velocity of the animation, and Compose state that gets updated for each frame, etc.\nisRunning is true until the animation is in progress and at the last frame of animation it gets toggle to false. This would terminate while loop leading to the end of state updates as well.\nLet‚Äôs enter the while loop. We have a call to callWithFrameNanos function accepting lambda that gets frame time in nanoseconds. This lambda will get invoked for each frame. This is essentially the first step we saw earlier, where we listen for the system frame. Zooming in further on callWithFrameNanos function leads us to a function call on the following.\nsuspend fun \u003cR\u003e withFrameNanos(onFrame: (frameTimeNanos: Long) -\u003e R): R { return coroutineContext.monotonicFrameClock.withFrameNanos(onFrame) } withFrameNanos function delegates call to monotonicFrameClock. Following is the abstraction of monotonicFrameClock.\ninterface MonotonicFrameClock: CoroutineContext.Element { /** * Suspends until a new frame is requested, immediately invokes [onFrame] * with the frame time in nanoseconds in the calling context of frame * dispatch, then resumes with the result from [onFrame]. */ suspend fun \u003cR\u003e withFrameNanos(onFrame: (frameTimeNanos: Long) -\u003e R): R . . . } The word abstraction is important here. We will see Android implementation in a bit. Before that, I want to address Compose multiplatform branching off from here. Each platform (iOS, Web, Windows, macOS, and Linux) has an implementation of this interface to listen for system frames. This makes listening to system frames on different platforms possible.\nComing back to Android implementation, Choreographer is being used to listen to frames. Choreographer is a framework-level utility class that coordinates frame rendering by syncing with device refresh rate. So for a 60 hz device, it schedules frame rendering every 16.67 ms. Besides scheduling it also exposes API to listen to the next frame. Following is the implementation of MonotonicFrameClock on Android.\nclass AndroidUiFrameClock internal constructor( val choreographer: Choreographer, private val dispatcher: AndroidUiDispatcher? ) : androidx.compose.runtime.MonotonicFrameClock { override suspend fun \u003cR\u003e withFrameNanos(onFrame: (Long) -\u003e R): R { . . return suspendCancellableCoroutine { co -\u003e val callback = Choreographer.FrameCallback { frameTimeNanos -\u003e co.resumeWith(runCatching { onFrame(frameTimeNanos) }) } . . } } The implementation above converts callback-based API from Choreographer to a suspending call. The function suspends waiting for the next frame and once it is ready it invokes onFrame lambda passing frame time in nanoseconds.\nAlright, so now we have frame time in nanoseconds. Let‚Äôs resume on onFrame lambda. Remember the place where we pass this lambda?\nLet me help you.\n. . . while (lateInitScope!!.isRunning) { val durationScale = coroutineContext.durationScale animation.callWithFrameNanos { frameTimeInNano -\u003e lateInitScope!!.doAnimationFrameWithScale( frameTimeInNano, durationScale, animation, this, block ) } } . . . callWithFrameNanos function above accepts the lambda. This is where we dig the rabbit hole to see how frame time is being listened on Android.\nWith frame time let‚Äôs see how it is being used to calculate the animation playtime. This is the second step from the four steps we saw earlier. doAnimationFrameWithScale function call above does that.\nprivate fun doAnimationFrameWithScale( frameTimeNanos: Long, durationScale: Float, anim: Animation\u003cT, V\u003e,\tstate: AnimationState\u003cT, V\u003e, block: AnimationScope\u003cT, V\u003e.() -\u003e Unit ) { val playTimeNanos = if (durationScale == 0f) { anim.durationNanos } else { ((frameTimeNanos - startTimeNanos) / durationScale).toLong() } doAnimationFrame(frameTimeNanos, playTimeNanos, anim, state, block) } The above function calculates playtime by subtracting the current frame time from the first frame time when the animation started. Notice this function also adjusts playtime to scale up or down based on the duration scale passed. This is something useful during the testing if you want to make your animation slow or fast.\nFinally, calculated playtime is passed to doAnimationFrame function. Here is the function implementation.\nprivate fun doAnimationFrame( frameTimeNanos: Long, playTimeNanos: Long, anim: Animation\u003cT, V\u003e, state: AnimationState\u003cT, V\u003e, block: AnimationScope\u003cT, V\u003e.() -\u003e Unit ) { lastFrameTimeNanos = frameTimeNanos value = anim.getValueFromNanos(playTimeNanos) velocityVector = anim.getVelocityVectorFromNanos(playTimeNanos) val isLastFrame = anim.isFinishedFromNanos(playTimeNanos) if (isLastFrame) { finishedTimeNanos = lastFrameTimeNanos isRunning = false } updateState(state) } This function feeds playtime to getValueFromNanos function on TargetBasedAnimation which calculates animation value. This is essentially the Animation API we saw in Part I which is a function of time. The black box I talked about in Part I is being used here.\nAlso, it calls isFinishedFromNanos function on TargetBasedAnimation to check if the current frame is the last frame of animation. If it is then it will set the isRunning to false. This will terminate the while loop to stop listening for frame further and terminate the animation.\nAt last, updateState function updates the Compose state that causes the recompisition. This completes the full circle for a frame. This keeps on repeating for the duration of Animation.\nParting Thoughts Damn! That‚Äôs a hell lot of things just to render one frame of animation. Hopefully, this was interesting and insightful. We saw system frame listener and Animation API are the cores powering Animatable API.\nIn the next part, we will explore animates*AsState and Transition APIs. Stay tuned!\n","wordCount":"1665","inLanguage":"en","image":"https://sagarviradiya.dev/images/header.jpeg","datePublished":"2024-11-30T00:00:00Z","dateModified":"2024-11-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sagarviradiya.dev/posts/compose-animation-part-02/"},"publisher":{"@type":"Organization","name":"Sagar's Blog","logo":{"@type":"ImageObject","url":"https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sagarviradiya.dev/ accesskey=h title="Sagar Viradiya (Alt + H)"><img src=https://sagarviradiya.dev/apple-touch-icon.png alt aria-label=logo height=35>Sagar Viradiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sagarviradiya.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sagarviradiya.dev/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://sagarviradiya.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://sagarviradiya.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sagarviradiya.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://sagarviradiya.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Compose Animation, Under The Hood - Part II</h1><div class=post-meta><span title='2024-11-30 00:00:00 +0000 UTC'>November 30, 2024</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;1665 words</div></header><figure class=entry-cover><a href=https://sagarviradiya.dev/posts/compose-animation-part-02/images/header.jpeg target=_blank rel="noopener noreferrer"><img loading=eager srcset="https://sagarviradiya.dev/posts/compose-animation-part-02/images/header_hu11667543973596740836.jpeg 360w ,https://sagarviradiya.dev/posts/compose-animation-part-02/images/header_hu6778699575449517851.jpeg 480w ,https://sagarviradiya.dev/posts/compose-animation-part-02/images/header_hu5131525609284878687.jpeg 720w ,https://sagarviradiya.dev/posts/compose-animation-part-02/images/header_hu7341933467799990330.jpeg 1080w ,https://sagarviradiya.dev/posts/compose-animation-part-02/images/header_hu17843387974648643720.jpeg 1500w ,https://sagarviradiya.dev/posts/compose-animation-part-02/images/header.jpeg 1792w" sizes="(min-width: 768px) 720px, 100vw" src=https://sagarviradiya.dev/posts/compose-animation-part-02/images/header.jpeg alt="[Generated With AI](https://www.bing.com/images/create/generate-header-image-for-blog-explaining-internal/1-66ffb250fccc43f588e2e34db8724eb4?id=JJRlbQKelN%2fMt%2f3JS0rXFw%3d%3d&view=detailv2&idpp=genimg&thId=OIG1.NpAOOqqUxD4ksSM_1iMa&skey=nRgIOQdbVScL_nCqQ1_pUwJdKJObIw0F24OkIDRyqH0&FORM=GCRIDP&mode=overlay)" width=1792 height=1024></a><p><a href="https://www.bing.com/images/create/generate-header-image-for-blog-explaining-internal/1-66ffb250fccc43f588e2e34db8724eb4?id=JJRlbQKelN%2fMt%2f3JS0rXFw%3d%3d&amp;view=detailv2&amp;idpp=genimg&amp;thId=OIG1.NpAOOqqUxD4ksSM_1iMa&amp;skey=nRgIOQdbVScL_nCqQ1_pUwJdKJObIw0F24OkIDRyqH0&amp;FORM=GCRIDP&amp;mode=overlay">Generated With AI</a></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context>Context</a></li><li><a href=#animatable>Animatable</a></li><li><a href=#animateto->animateTo üßê</a></li><li><a href=#parting-thoughts>Parting Thoughts</a></li></ul></nav></div></details></div><div class=post-content><h2 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h2><p>In <a href=https://sagarviradiya.dev/posts/compose-animation-part-02/>Part-I</a>, I explained how the Compose animation system leverages the low-level animation API to calculate the animation value for a given frame (playtime of animation). If you haven‚Äôt read that I would highly recommend reading that first before continuing here.</p><p>Things will get interesting in this part as we will explore how the Compose Animation system was built on top of Animation API. We will see how Animation API we saw in Part I gets consumed by Compose&rsquo;s Animatable API.</p><h2 id=animatable>Animatable<a hidden class=anchor aria-hidden=true href=#animatable>#</a></h2><p>Animatable is the stateful API. This means it has a Composable state wrapped in it that gets updated periodically for the duration of the animation. The state value exposed by Animatable is something end users use within Composable. Since Compose recomposes on every state change, the value exposed by Animatable causes rapid change in UI resulting in animation.</p><p>This API also keeps track of the progress of the animation. It knows where animation has reached based on the time passed since animation started and the duration of animation provided by the user.</p><p>The real beauty of this API is coroutine. Calling <code>animateTo</code> function causes thread suspension until it finishes the animation. This unlocks the possibility of running multiple animations parallelly or sequentially. Here is the cool animation that I found on <a href=https://lottiefiles.com/free-animation/laptop-animatiion-BBDW2PdPPr>Lottie</a> and reimplemented in Compose.</p><video controls autoplay loop muted style=max-width:100%;height:auto>
<source src=/videos/animation.mp4 type=video/mp4>Your browser does not support the video tag.</video><p>If you want to check implementation of above animation and more such sample animations then check out my open-source project <a href=https://github.com/sagar-viradiya/koreography>koreography</a>.</p><p>With this basic context on API, let&rsquo;s quickly see the code sample to know how you can consume this API.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Compose scope
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>isVisible</span> <span class=k>by</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>mutableStateOf</span><span class=p>(</span><span class=k>false</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>alphaAnimatable</span> <span class=p>=</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>Animatable</span><span class=p>(</span><span class=m>0f</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>LaunchedEffect</span><span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Coroutine Scope
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>alphaAnimatable</span><span class=p>.</span><span class=n>animateTo</span><span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span><span class=p>)</span>  <span class=c1>// Suspend function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>modifier</span> <span class=p>=</span> <span class=nc>Modifier</span><span class=p>.</span><span class=n>graphicsLayer</span> <span class=p>{</span> <span class=n>alpha</span> <span class=p>=</span> <span class=n>alphaAnimatable</span><span class=p>.</span><span class=k>value</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>painter</span> <span class=p>=</span> <span class=n>painterResource</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=nc>R</span><span class=p>.</span><span class=n>drawable</span><span class=p>.</span><span class=n>image</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>contentDescription</span> <span class=p>=</span> <span class=s2>&#34;Image&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Here we are triggering alpha animation on <code>isVisible</code> state change. Within launched effect, we call <code>animateTo</code> on <code>alphaAnimatable</code>. This will cause alpha to be animated towards 0 or 1 based on the <code>isVisible</code> state.</p><p>Notice how we are consuming alpha value exposed by Animatable within Image composable. The <code>alphaAnimatable.value</code> is essentially the value of the state wrapped in Animatable.</p><p>Nothing complicated here, this is just a Composable going through multiple recompositions (or relayout and redraw since we are using graphics layer API in the example to consume state) for a fixed duration of Animation. But how does this state changes happens?</p><p>Let&rsquo;s understand this with the following visuals.</p><video controls autoplay loop muted style=max-width:100%;height:auto>
<source src=/videos/animatable_frame_listner_flow.mp4 type=video/mp4>Your browser does not support the video tag.</video><p>Animatable wraps three things within. Animation, State, and FrameListner.</p><ol><li>FrameListener listens for the frames. When the next frame is ready to render, it gets a callback with frame time in nanoseconds.</li><li>Animatable then calculates the playtime of animation. By simply subtracting the first frame time (when the animation starts it stores the frame time) from the current frame time.</li><li>This playtime is then fed to Animation API. In Part I, we saw Animation API is a function of time. It accepts the playtime and calculates the value of animation at that particular playtime. Animation API then outputs the calculated value.</li><li>The calculated value is then applied to the state.</li></ol><p>The above 4 steps happen for each frame for the duration of Animation. Syncing with the system frame plays a crucial role here in keeping track of the progress of animation as well as calculating playtime.</p><p>Alright, that&rsquo;s all on the theory behind Animatable API. Let&rsquo;s see the above four steps in terms of the implementation perspective. Let&rsquo;s start with the entry point, the <code>animateTo</code> function call from the example earlier.</p><blockquote><p><em>For the scope of this blog, I am only covering target-based animation. I will leave decay-based animation up to you to explore. Hopefully, it will be easier to explore after reading this blog.</em></p></blockquote><h2 id=animateto->animateTo üßê<a hidden class=anchor aria-hidden=true href=#animateto->#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>animateTo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>targetValue</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>animationSpec</span><span class=p>:</span> <span class=n>AnimationSpec</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>defaultSpringSpec</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>initialVelocity</span><span class=p>:</span> <span class=n>T</span> <span class=p>=</span> <span class=n>velocity</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=p>(</span><span class=n>Animatable</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>)?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>AnimationResult</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>anim</span> <span class=p>=</span> <span class=n>TargetBasedAnimation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=n>animationSpec</span> <span class=p>=</span> <span class=n>animationSpec</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>initialValue</span> <span class=p>=</span> <span class=k>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>targetValue</span> <span class=p>=</span> <span class=n>targetValue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>typeConverter</span> <span class=p>=</span> <span class=n>typeConverter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>initialVelocity</span> <span class=p>=</span> <span class=n>initialVelocity</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>runAnimation</span><span class=p>(</span><span class=n>anim</span><span class=p>,</span> <span class=n>initialVelocity</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If we see the implementation of <code>animateTo</code> function, all it does is create <code>TargetBasedAnimation</code> passing <code>AnimationSpec</code>, target value, and other params. It then kicks in animation calling the internal function <code>runAnimation</code> passing newly created Animation and other params.</p><p>Alright, Let&rsquo;s dig further and see where calling <code>runAnimation</code> leads.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>lateInitScope</span><span class=o>!!</span><span class=p>.</span><span class=na>isRunning</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>val</span><span class=w> </span><span class=n>durationScale</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>coroutineContext</span><span class=p>.</span><span class=na>durationScale</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>animation</span><span class=p>.</span><span class=na>callWithFrameNanos</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>frameTimeInNano</span><span class=w> </span><span class=o>-&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lateInitScope</span><span class=o>!!</span><span class=p>.</span><span class=na>doAnimationFrameWithScale</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>frameTimeInNano</span><span class=p>,</span><span class=w> </span><span class=n>durationScale</span><span class=p>,</span><span class=w> </span><span class=n>animation</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><blockquote><p><em>For simplicity, I trim down code to focus on important things.</em></p></blockquote><p>Remember I mentioned earlier?, the four steps we saw keep repeating for each frame for the duration of the Animation. Well, above while loop takes care of that.</p><p>The <code>lateInitScope</code> is of type <code>AnimationScope</code>. <code>AnimationScope</code> is a class that provides all the animation related info specific to an animation run. Wrapping many things such as if animation is in progress (<code>isRunning</code> check in while loop above), current velocity of the animation, and Compose state that gets updated for each frame, etc.</p><p><code>isRunning</code> is true until the animation is in progress and at the last frame of animation it gets toggle to false. This would terminate while loop leading to the end of state updates as well.</p><p>Let&rsquo;s enter the while loop. We have a call to <code>callWithFrameNanos</code> function accepting lambda that gets frame time in nanoseconds. This lambda will get invoked for each frame. This is essentially the first step we saw earlier, where we listen for the system frame. Zooming in further on <code>callWithFrameNanos</code> function leads us to a function call on the following.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>R</span><span class=p>&gt;</span> <span class=nf>withFrameNanos</span><span class=p>(</span><span class=n>onFrame</span><span class=p>:</span> <span class=p>(</span><span class=n>frameTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>coroutineContext</span><span class=p>.</span><span class=n>monotonicFrameClock</span><span class=p>.</span><span class=n>withFrameNanos</span><span class=p>(</span><span class=n>onFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>withFrameNanos</code> function delegates call to <code>monotonicFrameClock</code>. Following is the abstraction of <code>monotonicFrameClock</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>interface</span> <span class=nc>MonotonicFrameClock</span><span class=p>:</span> <span class=nc>CoroutineContext</span><span class=p>.</span><span class=n>Element</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * Suspends until a new frame is requested, immediately invokes [onFrame] ¬† 
</span></span></span><span class=line><span class=cl><span class=cm>    * with the frame time in nanoseconds in the calling context of frame ¬† ¬† ¬† 	
</span></span></span><span class=line><span class=cl><span class=cm>    * dispatch, then resumes with the result from [onFrame].
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=k>suspend</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>R</span><span class=p>&gt;</span> <span class=nf>withFrameNanos</span><span class=p>(</span><span class=n>onFrame</span><span class=p>:</span> <span class=p>(</span><span class=n>frameTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The word abstraction is important here. We will see Android implementation in a bit. Before that, I want to address Compose multiplatform branching off from here. Each platform (iOS, Web, Windows, macOS, and Linux) has an implementation of this interface to listen for system frames. This makes listening to system frames on different platforms possible.</p><p>Coming back to Android implementation, Choreographer is being used to listen to frames. Choreographer is a framework-level utility class that coordinates frame rendering by syncing with device refresh rate. So for a 60 hz device, it schedules frame rendering every 16.67 ms. Besides scheduling it also exposes API to listen to the next frame. Following is the implementation of MonotonicFrameClock on Android.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>AndroidUiFrameClock</span> <span class=k>internal</span> <span class=k>constructor</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>choreographer</span><span class=p>:</span> <span class=n>Choreographer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>val</span> <span class=py>dispatcher</span><span class=p>:</span> <span class=n>AndroidUiDispatcher</span><span class=p>?</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>:</span> <span class=n>androidx</span><span class=p>.</span><span class=n>compose</span><span class=p>.</span><span class=n>runtime</span><span class=p>.</span><span class=n>MonotonicFrameClock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>suspend</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>R</span><span class=p>&gt;</span> <span class=nf>withFrameNanos</span><span class=p>(</span><span class=n>onFrame</span><span class=p>:</span> <span class=p>(</span><span class=n>Long</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span> 	<span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>suspendCancellableCoroutine</span> <span class=p>{</span> <span class=n>co</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>callback</span> <span class=p>=</span> <span class=nc>Choreographer</span><span class=p>.</span><span class=n>FrameCallback</span> <span class=p>{</span> <span class=n>frameTimeNanos</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>co</span><span class=p>.</span><span class=n>resumeWith</span><span class=p>(</span><span class=n>runCatching</span> <span class=p>{</span> <span class=n>onFrame</span><span class=p>(</span><span class=n>frameTimeNanos</span><span class=p>)</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The implementation above converts callback-based API from Choreographer to a suspending call. The function suspends waiting for the next frame and once it is ready it invokes <code>onFrame</code> lambda passing frame time in nanoseconds.</p><p>Alright, so now we have frame time in nanoseconds. Let&rsquo;s resume on <code>onFrame</code> lambda. Remember the place where we pass this lambda?</p><p>Let me help you.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>lateInitScope</span><span class=o>!!</span><span class=p>.</span><span class=na>isRunning</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>val</span><span class=w> </span><span class=n>durationScale</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>coroutineContext</span><span class=p>.</span><span class=na>durationScale</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>animation</span><span class=p>.</span><span class=na>callWithFrameNanos</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>frameTimeInNano</span><span class=w> </span><span class=o>-&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lateInitScope</span><span class=o>!!</span><span class=p>.</span><span class=na>doAnimationFrameWithScale</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>frameTimeInNano</span><span class=p>,</span><span class=w> </span><span class=n>durationScale</span><span class=p>,</span><span class=w> </span><span class=n>animation</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><p><code>callWithFrameNanos</code> function above accepts the lambda. This is where we dig the rabbit hole to see how frame time is being listened on Android.</p><p>With frame time let&rsquo;s see how it is being used to calculate the animation playtime. This is the second step from the four steps we saw earlier. <code>doAnimationFrameWithScale</code> function call above does that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>fun</span> <span class=nf>doAnimationFrameWithScale</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>frameTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>durationScale</span><span class=p>:</span> <span class=n>Float</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>anim</span><span class=p>:</span> <span class=n>Animation</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;,</span>	
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>:</span> <span class=n>AnimationState</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=n>AnimationScope</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>playTimeNanos</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>durationScale</span> <span class=o>==</span> <span class=m>0f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>anim</span><span class=p>.</span><span class=n>durationNanos</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=n>frameTimeNanos</span> <span class=p>-</span> <span class=n>startTimeNanos</span><span class=p>)</span> <span class=p>/</span> <span class=n>durationScale</span><span class=p>).</span><span class=n>toLong</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>doAnimationFrame</span><span class=p>(</span><span class=n>frameTimeNanos</span><span class=p>,</span> <span class=n>playTimeNanos</span><span class=p>,</span> <span class=n>anim</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above function calculates playtime by subtracting the current frame time from the first frame time when the animation started. Notice this function also adjusts playtime to scale up or down based on the duration scale passed. This is something useful during the testing if you want to make your animation slow or fast.</p><p>Finally, calculated playtime is passed to <code>doAnimationFrame</code> function. Here is the function implementation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>fun</span> <span class=nf>doAnimationFrame</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>frameTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>playTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>anim</span><span class=p>:</span> <span class=n>Animation</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>:</span> <span class=n>AnimationState</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=n>AnimationScope</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lastFrameTimeNanos</span> <span class=p>=</span> <span class=n>frameTimeNanos</span>
</span></span><span class=line><span class=cl>    <span class=k>value</span> <span class=p>=</span> <span class=n>anim</span><span class=p>.</span><span class=n>getValueFromNanos</span><span class=p>(</span><span class=n>playTimeNanos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>velocityVector</span> <span class=p>=</span> <span class=n>anim</span><span class=p>.</span><span class=n>getVelocityVectorFromNanos</span><span class=p>(</span><span class=n>playTimeNanos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>isLastFrame</span> <span class=p>=</span> <span class=n>anim</span><span class=p>.</span><span class=n>isFinishedFromNanos</span><span class=p>(</span><span class=n>playTimeNanos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isLastFrame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>finishedTimeNanos</span> <span class=p>=</span> <span class=n>lastFrameTimeNanos</span>
</span></span><span class=line><span class=cl>        <span class=n>isRunning</span> <span class=p>=</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>updateState</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This function feeds playtime to <code>getValueFromNanos</code> function on TargetBasedAnimation which calculates animation value. This is essentially the Animation API we saw in Part I which is a function of time. The black box I talked about in Part I is being used here.</p><p>Also, it calls <code>isFinishedFromNanos</code> function on TargetBasedAnimation to check if the current frame is the last frame of animation. If it is then it will set the <code>isRunning</code> to false. This will terminate the while loop to stop listening for frame further and terminate the animation.</p><p>At last, <code>updateState</code> function updates the Compose state that causes the recompisition. This completes the full circle for a frame. This keeps on repeating for the duration of Animation.</p><h2 id=parting-thoughts>Parting Thoughts<a hidden class=anchor aria-hidden=true href=#parting-thoughts>#</a></h2><p>Damn! That&rsquo;s a hell lot of things just to render one frame of animation. Hopefully, this was interesting and insightful. We saw system frame listener and Animation API are the cores powering Animatable API.</p><p>In the next part, we will explore animates*AsState and Transition APIs. Stay tuned!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sagarviradiya.dev/tags/compose/>Compose</a></li><li><a href=https://sagarviradiya.dev/tags/animation/>Animation</a></li></ul><nav class=paginav><a class=next href=https://sagarviradiya.dev/posts/compose-animation-part-01/><span class=title>Next ¬ª</span><br><span>Compose Animation, Under The Hood - Part I</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//sagarviradiya-dev.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://sagarviradiya.dev/>Sagar's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>