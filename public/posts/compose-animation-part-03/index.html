<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Compose Animation, Under The Hood - Part III | Sagar's Blog</title>
<meta name=keywords content="Compose,Animation"><meta name=description content="A deep dive on animate*AsState and Transition API."><meta name=author content><link rel=canonical href=https://sagarviradiya.dev/posts/compose-animation-part-03/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.083b73ab99f7bb76228f3b506c8b579236a3f308e4021b0c281be819e5d67681.css integrity="sha256-CDtzq5n3u3YijztQbItXkjaj8wjkAhsMKBvoGeXWdoE=" rel="preload stylesheet" as=style><link rel=icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sagarviradiya.dev/posts/compose-animation-part-03/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://sagarviradiya.dev/posts/compose-animation-part-03/"><meta property="og:site_name" content="Sagar's Blog"><meta property="og:title" content="Compose Animation, Under The Hood - Part III"><meta property="og:description" content="A deep dive on animate*AsState and Transition API."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-06T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-06T00:00:00+00:00"><meta property="article:tag" content="Compose"><meta property="article:tag" content="Animation"><meta property="og:image" content="https://sagarviradiya.dev/images/header.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sagarviradiya.dev/images/header.jpeg"><meta name=twitter:title content="Compose Animation, Under The Hood - Part III"><meta name=twitter:description content="A deep dive on animate*AsState and Transition API."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sagarviradiya.dev/posts/"},{"@type":"ListItem","position":2,"name":"Compose Animation, Under The Hood - Part III","item":"https://sagarviradiya.dev/posts/compose-animation-part-03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Compose Animation, Under The Hood - Part III","name":"Compose Animation, Under The Hood - Part III","description":"A deep dive on animate*AsState and Transition API.","keywords":["Compose","Animation"],"articleBody":"Context In Part-II we explored the low-level Animatable API, which leverages Animation API and coroutines to unlock the possibility of composing complex animations running parallelly or sequentially.\nWhile this API offers fine control over the animation, most of the time you want simple animations. Things like scaling, rotating or changing alpha, based on some state change within compose. Sometimes you need to run multiple animations together based on state change.\nanimate*AsState and Transition APIs built on top of Animatable and Animation, respectively, are the two high-level APIs that allow you to implement such animations. In this part we will see the implementation details of these two APIs.\nIf you haven‚Äôt read the first two parts I would suggest reading them before continuing here.\nPart-I covering low level Animation API. Part-II covering Animatable API. animate*AsState This is just a composable wrapping Animatable and exposing its state. Since this is the composable function it can observe state change. Based on state value, it internally triggers the animation towards the new target. So essentially, the input for this API is state, and the output is the state object that your composable observes and recomposes.\nLet‚Äôs understand this using an example.\n// Compose Context val isVisible by remember { mutableStateOf(false) } val alphaState: State\u003cFloat\u003e = animateFloatAsState( targetValue = if (isVisible) 1f else 0f,¬†label = \"alphaAnimation\" ) Image( modifier = Modifier.graphicsLayer { alpha = alphaState.value }, painter = painterResource(id = R.drawable.image), contentDescription = \"Image\" ) Here we are, toggling the visibility of image based on state change. Notice isVisible above is the state value observed by animateFloatAsState. If it is true, then the target value of animation is 1 else 0. animateFloatAsState composable returns another state object of float. This state object is then applied to the alpha of the image.\nThe above example animates the value of type float, but there are composables to animate Int (animateIntAsState), Offset (animateOffsetAsState), Rect (animateRectAsState), DP(animateDpAsState) etc. In fact, you can animate your custom object type if you provide TwoWayConverter(Refer to Part-I if you want to know more about TwoWayConverter) to the generic animateValueAsState function. All the built-in composables, animateIntAsState, animateFloatAsState, animateRectAsState, animateDpAsState, etc, internally call animateValueAsState only by passing TwoWayConverter of respective type.\nHopefully, by now, you have a better understanding of the API and curious to know its implementation. Since everything boils down to animateValueAsState, let‚Äôs zoom into the function.\n@Composable public fun \u003cT, V : AnimationVector\u003e animateValueAsState( targetValue: T, typeConverter: TwoWayConverter\u003cT, V\u003e, animationSpec: AnimationSpec\u003cT\u003e = remember { spring() }, visibilityThreshold: T? = null, label: String = \"ValueAnimation\", finishedListener: ((T) -\u003e Unit)? = null ): State\u003cT\u003e { . . val animatable = remember { Animatable(targetValue, typeConverter, visibilityThreshold, label) } . . . val channel = remember { Channel\u003cT\u003e(Channel.CONFLATED) } SideEffect { channel.trySend(targetValue) } LaunchedEffect(channel) { for (target in channel) { val newTarget = channel.tryReceive().getOrNull() ?: target launch { if (newTarget != animatable.targetValue) { animatable.animateTo(newTarget, animSpec) listener?.invoke(animatable.value) } } } } return toolingOverride.value ?: animatable.asState() } This is the trim-down version of full implementation.\nThis composable remembers Animatable with an initial target. Remember I said wrapping Animatable ? This is exactly what I meant.\nInternally, it uses channel to dispatch target change. The SideEffect above gets executed every time there is a change in the target. Within this block, we are dispatching new target values to the channel.\nThis channel is then observed within LaunchedEffect, and if the new target is different from the existing target, it starts the animation.\nFinally, outside the LaunchedEffect at the end, the function returns state from the Animatable. This state object is updated on each frame by Animatable resulting in Animation.\ntoolingOverride above is for overriding the actual animation state with the default tooling state. This will be used while composable is in preview mode.\nThat concludes animate*AsState API. A simple wrapper over Animatable.\nTransition Transition API triggers multiple animations on state change. For each animation, it maintains a state object tracking its current value, whether the animation is finished, etc. This state object holds the reference of low-level Animation API and delegates animation to it. So essentially, Transition API is a wrapper over Animation API.\nBefore we dive into the implementation details, Let‚Äôs see how you can consume this API.\n// Compose Context var isVisible by remember {¬†mutableStateOf(false)¬†} val transition = updateTransition(target = isVisible) val alpha by transition.animateFloat( label = \"Alpha\" ) { isVisible -\u003e if (isVisible) 1f else 0f } val scale by transition.animateFloat( label = \"Scale\" ) { isVisible -\u003e if (isVisible) 1f else 0f } We have isVisibile mutable state that is being passed to updateTransition composable. This composable internally creates, remembers, and returns an instance of Transition.\nWith this Transition instance, you can create child animations. In the above example, two animations are created. The first animation is for animating alpha, and the second animates the scale. Notice the trailing lambda of animateFloat function. It exposes the isVisibile state value that is observed by transition. Based on this state value we decide the target for child animation.\nFinally, you can apply this alpha and scale to animate composable.\nImage( modifier = Modifier.graphicsLayer { alpha = alpha scale = scale }, painter = painterResource(id = R.drawable.image), contentDescription = \"Image\" ) Now that we are clear on how we can consume Transition API, let‚Äôs zoom into the implementation üßê\nIt starts with updateTransition composable.\n@Composable public fun \u003cT\u003e updateTransition(targetState: T, label: String? = null): Transition\u003cT\u003e { val transition = remember { Transition(targetState, label = label) } transition.animateTo(targetState) DisposableEffect(transition) { onDispose { transition.onDisposed() } } return transition } Nothing complicated here. It just creates an instance of Transition and remembers it. Since this is composable, every time there is a change in the target state that is being passed to this function, it recomposes and calls animateTo on Transition passing a new target state. Transition then triggers all child animations towards their new respective targets.\nIt also takes care of disposing transition when the composition exits. Finally, it returns the created instance of transition.\nThe above composable is merely a thin wrapper delegating target change to Transition. Let‚Äôs zoom into the Transition implementation.\npublic class Transition\u003cS\u003e { . . . public val animations: List\u003cTransitionAnimationState\u003c*, *\u003e\u003e get() = _animations . . . internal fun animateTo(targetState: S) { . . . while (isActive) { withFrameNanos { if (!isSeeking) { frameTimeNanos -\u003e onFrame(frameTimeNanos / AnimationDebugDurationScale, durationScale) } } } . . . } } This is the ultra trim-down version of the actual implementation. There is a lot going on in this class and I encourage you to explore it.\nTwo things I want to focus on here are a list of TransitionAnimationState and animateTo function.\nThe list of TransitionAnimationState above holds the state of each child animation. This list is populated when you create the child animation on Transition. Remember this?\nval alpha by transition.animateFloat( label = \"Alpha\" ) { isVisible -\u003e if (isVisible) 1f else 0f } This was one of the child animations we created earlier in the example. When you call animate* (animateInt, animateFloat, animateIntOffset etc) on transition, it internally creates TransitionAnimationState, passing the initial target value and adds it to the list.\nThe animateTo function is the entry point to Transition API, which will be called by updateTransition composable function on state change. This function starts listening to new frames from the choreographer. In Part-II of this series, we saw the implementation details of frame listening. I am not covering it again as it is same here as well.\nThe trailing lambda of withFrameNanos will get called for each frame. This lambda gets the frame time in nanoseconds. Later, this frame time is used to calculate the playtime of animation within onFrame function. Again, the calculation of play time is very similar to what we saw in Part-II. I would leave this to you as an exercise to explore onFrame function.\nThe calculated playtime of the animation is then fed to each child animation represented by TransitionAnimationState.\n_animations.fastForEach { . . it.onPlayTimeChanged(scaledPlayTimeNanos, scaleToEnd) . . } Now that playtime is available and fed to each child animation, let‚Äôs see the implementation details of TransitionAnimationState to understand how animation value is calculated for a frame.\npublic inner class TransitionAnimationState\u003cT, V : AnimationVector\u003e) : State\u003cT\u003e { . . . public var animation: TargetBasedAnimation\u003cT, V\u003e by mutableStateOf( TargetBasedAnimation( animationSpec, typeConverter, initialValue, targetValue, initialVelocityVector ) ) private set . . . override var value: T by mutableStateOf(initialValue) internal set . . . internal fun onPlayTimeChanged(playTimeNanos: Long, scaleToEnd: Boolean) { val playTime = if (scaleToEnd) animation.durationNanos else playTimeNanos value = animation.getValueFromNanos(playTime) velocityVector = animation.getVelocityVectorFromNanos(playTime) if (animation.isFinishedFromNanos(playTime)) { isFinished = true } } } Again, this is the ultra trim-down version of the actual implementation.\nLet‚Äôs break down a simplified version of the TransitionAnimationState class and understand how it works.\nThis class represents the internal state of child animation. It implements State, making it observable in Compose. Whenever its value changes, the UI will recompose accordingly. This is what you get back when you create child animation on transition.\nval alpha by transition.animateFloat( label = \"Alpha\" ) { isVisible -\u003e if (isVisible) 1f else 0f } The animateFloat above returns State, which is nothing but TransitionAnimationState\nThe animation playtime we calculated is fed to onPlayTimeChanged, which internally feeds this playtime to Animation to calculate the animation value for the frame. This animation value is then applied to the state, resulting in recomposition of your Composable.\nTo understand how Animation calculates value based on playtime please head to Part-I of this series, where I detailed this.\nSummary This concludes the implementation details of two high-level Animation APIs, which animate things on state change. While these APIs look different from others, they leverage low-level Animation APIs to hide boilerplate code that you need to write otherwise. Let‚Äôs summarise them.\nanimate*AsState This is a composable wrapping Animatable and delegates animation to it. Internally it uses channel to publish all state change and observe this channel within LauchedEffect to forward state changes to Animatable Transition updateTransition composable is the entry point that internally creates a Transition object. Transition react to state changes, start listening for frame changes, and forward them to all child animations Child animations are wrapped in TransitionAnimationState object, which reacts to frame change from Transition and internally delegates animation to Animation API. The updated animation values are then applied to TransitionAnimationState which causes recomposition Parting Thoughts I know this is a bit heavy to digest. I would recommend reading this along with the full implementation open on cs.android.com.\nIf you are still here, you are brave! Pet yourself on the back. Honestly, I am unsure if I simplified this enough to sink this in. Transition animation was by far difficult to explain as it involves multiple animations and additional state objects.\nWith this part, I am concluding this series on the internals of Compose animation API. I hope this series was insightful. If you have any suggestions or questions, please drop them in the comment below. Until then, stay curious!\n","wordCount":"1829","inLanguage":"en","image":"https://sagarviradiya.dev/images/header.jpeg","datePublished":"2025-04-06T00:00:00Z","dateModified":"2025-04-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sagarviradiya.dev/posts/compose-animation-part-03/"},"publisher":{"@type":"Organization","name":"Sagar's Blog","logo":{"@type":"ImageObject","url":"https://sagarviradiya.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sagarviradiya.dev/ accesskey=h title="Sagar Viradiya (Alt + H)"><img src=https://sagarviradiya.dev/apple-touch-icon.png alt aria-label=logo height=35>Sagar Viradiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sagarviradiya.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sagarviradiya.dev/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://sagarviradiya.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://sagarviradiya.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sagarviradiya.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://sagarviradiya.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Compose Animation, Under The Hood - Part III</h1><div class=post-meta><span title='2025-04-06 00:00:00 +0000 UTC'>April 6, 2025</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;1829 words</div></header><figure class=entry-cover><a href=https://sagarviradiya.dev/posts/compose-animation-part-03/images/header.jpeg target=_blank rel="noopener noreferrer"><img loading=eager srcset="https://sagarviradiya.dev/posts/compose-animation-part-03/images/header_hu11667543973596740836.jpeg 360w ,https://sagarviradiya.dev/posts/compose-animation-part-03/images/header_hu6778699575449517851.jpeg 480w ,https://sagarviradiya.dev/posts/compose-animation-part-03/images/header_hu5131525609284878687.jpeg 720w ,https://sagarviradiya.dev/posts/compose-animation-part-03/images/header_hu7341933467799990330.jpeg 1080w ,https://sagarviradiya.dev/posts/compose-animation-part-03/images/header_hu17843387974648643720.jpeg 1500w ,https://sagarviradiya.dev/posts/compose-animation-part-03/images/header.jpeg 1792w" sizes="(min-width: 768px) 720px, 100vw" src=https://sagarviradiya.dev/posts/compose-animation-part-03/images/header.jpeg alt="[Generated With AI](https://www.bing.com/images/create/generate-header-image-for-blog-explaining-internal/1-66ffb250fccc43f588e2e34db8724eb4?id=JJRlbQKelN%2fMt%2f3JS0rXFw%3d%3d&view=detailv2&idpp=genimg&thId=OIG1.NpAOOqqUxD4ksSM_1iMa&skey=nRgIOQdbVScL_nCqQ1_pUwJdKJObIw0F24OkIDRyqH0&FORM=GCRIDP&mode=overlay)" width=1792 height=1024></a><p><a href="https://www.bing.com/images/create/generate-header-image-for-blog-explaining-internal/1-66ffb250fccc43f588e2e34db8724eb4?id=JJRlbQKelN%2fMt%2f3JS0rXFw%3d%3d&amp;view=detailv2&amp;idpp=genimg&amp;thId=OIG1.NpAOOqqUxD4ksSM_1iMa&amp;skey=nRgIOQdbVScL_nCqQ1_pUwJdKJObIw0F24OkIDRyqH0&amp;FORM=GCRIDP&amp;mode=overlay">Generated With AI</a></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context>Context</a></li><li><a href=#animateasstate>animate*AsState</a></li><li><a href=#transition>Transition</a></li><li><a href=#summary>Summary</a><ul><li><a href=#animateasstate-1>animate*AsState</a></li><li><a href=#transition-1>Transition</a></li></ul></li><li><a href=#parting-thoughts>Parting Thoughts</a></li></ul></nav></div></details></div><div class=post-content><h2 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h2><p>In <a href=https://sagarviradiya.dev/posts/compose-animation-part-02/>Part-II</a> we explored the low-level <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> API, which leverages <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> API and coroutines to unlock the possibility of composing complex animations running parallelly or sequentially.</p><p>While this API offers fine control over the animation, most of the time you want simple animations. Things like scaling, rotating or changing alpha, based on some state change within compose. Sometimes you need to run multiple animations together based on state change.</p><p><a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/AnimateAsState.kt;drc=e5cf676e339f2807cf29bf28fe7d8364931a48eb;l=389"><code>animate*AsState</code></a> and <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> APIs built on top of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> and <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a>, respectively, are the two high-level APIs that allow you to implement such animations.
In this part we will see the implementation details of these two APIs.</p><p>If you haven&rsquo;t read the first two parts I would suggest reading them before continuing here.</p><ol><li><a href=https://sagarviradiya.dev/posts/compose-animation-part-01/>Part-I</a> covering low level Animation API.</li><li><a href=https://sagarviradiya.dev/posts/compose-animation-part-02/>Part-II</a> covering Animatable API.</li></ol><h2 id=animateasstate>animate*AsState<a hidden class=anchor aria-hidden=true href=#animateasstate>#</a></h2><p>This is just a composable wrapping <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> and exposing its state. Since this is the composable function it can observe state change. Based on state value, it internally triggers the animation towards the new target. So essentially, the input for this API is state, and the output is the state object that your composable observes and recomposes.</p><p>Let&rsquo;s understand this using an example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Compose Context  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>isVisible</span> <span class=k>by</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>mutableStateOf</span><span class=p>(</span><span class=k>false</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>alphaState</span><span class=p>:</span> <span class=n>State</span><span class=p>&lt;</span><span class=n>Float</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>animateFloatAsState</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>targetValue</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span><span class=p>,</span>¬†
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=p>=</span> <span class=s2>&#34;alphaAnimation&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>modifier</span> <span class=p>=</span> <span class=nc>Modifier</span><span class=p>.</span><span class=n>graphicsLayer</span> <span class=p>{</span> <span class=n>alpha</span> <span class=p>=</span> <span class=n>alphaState</span><span class=p>.</span><span class=k>value</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>painter</span> <span class=p>=</span> <span class=n>painterResource</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=nc>R</span><span class=p>.</span><span class=n>drawable</span><span class=p>.</span><span class=n>image</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>contentDescription</span> <span class=p>=</span> <span class=s2>&#34;Image&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Here we are, toggling the visibility of image based on state change. Notice <code>isVisible</code> above is the state value observed by <code>animateFloatAsState</code>. If it is true, then the target value of animation is 1 else 0. <code>animateFloatAsState</code> composable returns another state object of float. This state object is then applied to the alpha of the image.</p><p>The above example animates the value of type float, but there are composables to animate Int (<code>animateIntAsState</code>), Offset (<code>animateOffsetAsState</code>), Rect (<code>animateRectAsState</code>), DP(<code>animateDpAsState</code>) etc. In fact, you can animate your custom object type if you provide <code>TwoWayConverter</code>(Refer to <a href=https://sagarviradiya.dev/posts/compose-animation-part-01/>Part-I</a> if you want to know more about <code>TwoWayConverter</code>) to the generic <code>animateValueAsState</code> function. All the built-in composables, <code>animateIntAsState</code>, <code>animateFloatAsState</code>, <code>animateRectAsState</code>, <code>animateDpAsState</code>, etc, internally call <code>animateValueAsState</code> only by passing <code>TwoWayConverter</code> of respective type.</p><p>Hopefully, by now, you have a better understanding of the API and curious to know its implementation. Since everything boils down to <code>animateValueAsState</code>, let&rsquo;s zoom into the function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Composable</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>V</span> <span class=p>:</span> <span class=nc>AnimationVector</span><span class=p>&gt;</span> <span class=nf>animateValueAsState</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>targetValue</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>typeConverter</span><span class=p>:</span> <span class=n>TwoWayConverter</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=n>animationSpec</span><span class=p>:</span> <span class=n>AnimationSpec</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>spring</span><span class=p>()</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>visibilityThreshold</span><span class=p>:</span> <span class=n>T</span><span class=p>?</span> <span class=p>=</span> <span class=k>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;ValueAnimation&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>finishedListener</span><span class=p>:</span> <span class=p>((</span><span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>)?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>State</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>animatable</span> <span class=p>=</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>Animatable</span><span class=p>(</span><span class=n>targetValue</span><span class=p>,</span> <span class=n>typeConverter</span><span class=p>,</span> <span class=n>visibilityThreshold</span><span class=p>,</span> <span class=n>label</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>channel</span> <span class=p>=</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>Channel</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span><span class=nc>Channel</span><span class=p>.</span><span class=n>CONFLATED</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>SideEffect</span> <span class=p>{</span> <span class=n>channel</span><span class=p>.</span><span class=n>trySend</span><span class=p>(</span><span class=n>targetValue</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>LaunchedEffect</span><span class=p>(</span><span class=n>channel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>target</span> <span class=k>in</span> <span class=n>channel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>newTarget</span> <span class=p>=</span> <span class=n>channel</span><span class=p>.</span><span class=n>tryReceive</span><span class=p>().</span><span class=n>getOrNull</span><span class=p>()</span> <span class=o>?:</span> <span class=n>target</span>
</span></span><span class=line><span class=cl>            <span class=n>launch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>newTarget</span> <span class=o>!=</span> <span class=n>animatable</span><span class=p>.</span><span class=n>targetValue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>animatable</span><span class=p>.</span><span class=n>animateTo</span><span class=p>(</span><span class=n>newTarget</span><span class=p>,</span> <span class=n>animSpec</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>listener</span><span class=o>?.</span><span class=n>invoke</span><span class=p>(</span><span class=n>animatable</span><span class=p>.</span><span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>toolingOverride</span><span class=p>.</span><span class=k>value</span> <span class=o>?:</span> <span class=n>animatable</span><span class=p>.</span><span class=n>asState</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><em>This is the trim-down version of full implementation.</em></p></blockquote><p>This composable remembers <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> with an initial target. Remember I said wrapping <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> ? This is exactly what I meant.</p><p>Internally, it uses channel to dispatch target change. The <code>SideEffect</code> above gets executed every time there is a change in the target. Within this block, we are dispatching new target values to the channel.</p><p>This channel is then observed within <code>LaunchedEffect</code>, and if the new target is different from the existing target, it starts the animation.</p><p>Finally, outside the <code>LaunchedEffect</code> at the end, the function returns state from the <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a>. This state object is updated on each frame by <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> resulting in Animation.</p><blockquote><p><em><code>toolingOverride</code> above is for overriding the actual animation state with the default tooling state. This will be used while composable is in preview mode.</em></p></blockquote><p>That concludes <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/AnimateAsState.kt;drc=e5cf676e339f2807cf29bf28fe7d8364931a48eb;l=389"><code>animate*AsState</code></a> API. A simple wrapper over <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a>.</p><h2 id=transition>Transition<a hidden class=anchor aria-hidden=true href=#transition>#</a></h2><p>Transition API triggers multiple animations on state change. For each animation, it maintains a state object tracking its current value, whether the animation is finished, etc. This state object holds the reference of low-level <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> API and delegates animation to it. So essentially, Transition API is a wrapper over <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> API.</p><p>Before we dive into the implementation details, Let&rsquo;s see how you can consume this API.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Compose Context
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>var</span> <span class=py>isVisible</span> <span class=k>by</span> <span class=n>remember</span> <span class=p>{</span>¬†<span class=n>mutableStateOf</span><span class=p>(</span><span class=k>false</span><span class=p>)</span>¬†<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>transition</span> <span class=p>=</span> <span class=n>updateTransition</span><span class=p>(</span><span class=n>target</span> <span class=p>=</span> <span class=n>isVisible</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>alpha</span> <span class=k>by</span> <span class=n>transition</span><span class=p>.</span><span class=n>animateFloat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>¬†¬†¬†¬†<span class=n>label</span> <span class=p>=</span> <span class=s2>&#34;Alpha&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span> <span class=n>isVisible</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>scale</span> <span class=k>by</span> <span class=n>transition</span><span class=p>.</span><span class=n>animateFloat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=p>=</span> <span class=s2>&#34;Scale&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span> <span class=n>isVisible</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We have <code>isVisibile</code> mutable state that is being passed to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=0c832c139dc844fcc611c7b5cdb1496ba5071a3a;l=88"><code>updateTransition</code></a> composable. This composable internally creates, remembers, and returns an instance of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a>.</p><p>With this <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> instance, you can create child animations. In the above example, two animations are created. The first animation is for animating alpha, and the second animates the scale. Notice the trailing lambda of <code>animateFloat</code> function. It exposes the <code>isVisibile</code> state value that is observed by transition. Based on this state value we decide the target for child animation.</p><p>Finally, you can apply this alpha and scale to animate composable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>Image</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>modifier</span> <span class=p>=</span> <span class=nc>Modifier</span><span class=p>.</span><span class=n>graphicsLayer</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	    <span class=n>alpha</span> <span class=p>=</span> <span class=n>alpha</span> 
</span></span><span class=line><span class=cl>	    <span class=n>scale</span> <span class=p>=</span> <span class=n>scale</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>painter</span> <span class=p>=</span> <span class=n>painterResource</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=nc>R</span><span class=p>.</span><span class=n>drawable</span><span class=p>.</span><span class=n>image</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>contentDescription</span> <span class=p>=</span> <span class=s2>&#34;Image&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Now that we are clear on how we can consume Transition API, let&rsquo;s zoom into the implementation üßê</p><p>It starts with <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=0c832c139dc844fcc611c7b5cdb1496ba5071a3a;l=88"><code>updateTransition</code></a> composable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Composable</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>updateTransition</span><span class=p>(</span><span class=n>targetState</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span> <span class=n>label</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=k>null</span><span class=p>):</span> <span class=n>Transition</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>transition</span> <span class=p>=</span> <span class=n>remember</span> <span class=p>{</span> <span class=n>Transition</span><span class=p>(</span><span class=n>targetState</span><span class=p>,</span> <span class=n>label</span> <span class=p>=</span> <span class=n>label</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>transition</span><span class=p>.</span><span class=n>animateTo</span><span class=p>(</span><span class=n>targetState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DisposableEffect</span><span class=p>(</span><span class=n>transition</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>onDispose</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>transition</span><span class=p>.</span><span class=n>onDisposed</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>transition</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Nothing complicated here. It just creates an instance of Transition and remembers it. Since this is composable, every time there is a change in the target state that is being passed to this function, it recomposes and calls <code>animateTo</code> on Transition passing a new target state. Transition then triggers all child animations towards their new respective targets.</p><p>It also takes care of disposing transition when the composition exits. Finally, it returns the created instance of transition.</p><p>The above composable is merely a thin wrapper delegating target change to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a>. Let&rsquo;s zoom into the <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> implementation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Transition</span><span class=p>&lt;</span><span class=n>S</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>val</span> <span class=py>animations</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>TransitionAnimationState</span><span class=p>&lt;*,</span> <span class=p>*&gt;&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=n>_animations</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>internal</span> <span class=k>fun</span> <span class=nf>animateTo</span><span class=p>(</span><span class=n>targetState</span><span class=p>:</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>    
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>isActive</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>withFrameNanos</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!is</span><span class=n>Seeking</span><span class=p>)</span> <span class=p>{</span> <span class=n>frameTimeNanos</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=n>onFrame</span><span class=p>(</span><span class=n>frameTimeNanos</span> <span class=p>/</span> <span class=n>AnimationDebugDurationScale</span><span class=p>,</span> <span class=n>durationScale</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>    
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><em>This is the ultra trim-down version of the actual implementation. There is a lot going on in this class and I encourage you to explore it.</em></p></blockquote><p>Two things I want to focus on here are a list of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> and <code>animateTo</code> function.</p><p>The list of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> above holds the state of each child animation. This list is populated when you create the child animation on <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a>. Remember this?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>alpha</span> <span class=k>by</span> <span class=n>transition</span><span class=p>.</span><span class=n>animateFloat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=p>=</span> <span class=s2>&#34;Alpha&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span> <span class=n>isVisible</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This was one of the child animations we created earlier in the example. When you call <code>animate*</code> (<code>animateInt</code>, <code>animateFloat</code>, <code>animateIntOffset</code> etc) on transition, it internally creates <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a>, passing the initial target value and adds it to the list.</p><p>The <code>animateTo</code> function is the entry point to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> API, which will be called by <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=0c832c139dc844fcc611c7b5cdb1496ba5071a3a;l=88"><code>updateTransition</code></a> composable function on state change. This function starts listening to new frames from the choreographer. In <a href=https://sagarviradiya.dev/posts/compose-animation-part-02/>Part-II</a> of this series, we saw the implementation details of frame listening. I am not covering it again as it is same here as well.</p><p>The trailing lambda of <code>withFrameNanos</code> will get called for each frame. This lambda gets the frame time in nanoseconds. Later, this frame time is used to calculate the playtime of animation within <code>onFrame</code> function. Again, the calculation of play time is very similar to what we saw in <a href=https://sagarviradiya.dev/posts/compose-animation-part-02/>Part-II</a>. I would leave this to you as an exercise to explore <code>onFrame</code> function.</p><p>The calculated playtime of the animation is then fed to each child animation represented by <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl> <span class=n>_animations</span><span class=p>.</span><span class=n>fastForEach</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>it</span><span class=p>.</span><span class=n>onPlayTimeChanged</span><span class=p>(</span><span class=n>scaledPlayTimeNanos</span><span class=p>,</span> <span class=n>scaleToEnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now that playtime is available and fed to each child animation, let&rsquo;s see the implementation details of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> to understand how animation value is calculated for a frame.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>inner</span> <span class=k>class</span> <span class=nc>TransitionAnimationState</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span> <span class=p>:</span> <span class=n>AnimationVector</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=n>State</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>var</span> <span class=py>animation</span><span class=p>:</span> <span class=n>TargetBasedAnimation</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;</span> <span class=k>by</span>
</span></span><span class=line><span class=cl>        <span class=n>mutableStateOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>TargetBasedAnimation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>animationSpec</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>typeConverter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>initialValue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>targetValue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>initialVelocityVector</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span> <span class=k>set</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>var</span> <span class=py>value</span><span class=p>:</span> <span class=n>T</span> <span class=k>by</span> <span class=n>mutableStateOf</span><span class=p>(</span><span class=n>initialValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>internal</span> <span class=k>set</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=k>internal</span> <span class=k>fun</span> <span class=nf>onPlayTimeChanged</span><span class=p>(</span><span class=n>playTimeNanos</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span> <span class=n>scaleToEnd</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>playTime</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>scaleToEnd</span><span class=p>)</span> <span class=n>animation</span><span class=p>.</span><span class=n>durationNanos</span> <span class=k>else</span> <span class=n>playTimeNanos</span>
</span></span><span class=line><span class=cl>        <span class=k>value</span> <span class=p>=</span> <span class=n>animation</span><span class=p>.</span><span class=n>getValueFromNanos</span><span class=p>(</span><span class=n>playTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>velocityVector</span> <span class=p>=</span> <span class=n>animation</span><span class=p>.</span><span class=n>getVelocityVectorFromNanos</span><span class=p>(</span><span class=n>playTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>animation</span><span class=p>.</span><span class=n>isFinishedFromNanos</span><span class=p>(</span><span class=n>playTime</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>isFinished</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><em>Again, this is the ultra trim-down version of the actual implementation.</em></p></blockquote><p>Let‚Äôs break down a simplified version of the <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> class and understand how it works.</p><p>This class represents the internal state of child animation. It implements <code>State&lt;T></code>, making it observable in Compose. Whenever its value changes, the UI will recompose accordingly. This is what you get back when you create child animation on transition.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>alpha</span> <span class=k>by</span> <span class=n>transition</span><span class=p>.</span><span class=n>animateFloat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=p>=</span> <span class=s2>&#34;Alpha&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span> <span class=n>isVisible</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isVisible</span><span class=p>)</span> <span class=m>1f</span> <span class=k>else</span> <span class=m>0f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>animateFloat</code> above returns <code>State&lt;Float></code>, which is nothing but <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a></p><p>The animation playtime we calculated is fed to <code>onPlayTimeChanged</code>, which internally feeds this playtime to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> to calculate the animation value for the frame. This animation value is then applied to the state, resulting in recomposition of your Composable.</p><blockquote><p><em>To understand how <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> calculates value based on playtime please head to <a href=https://sagarviradiya.dev/posts/compose-animation-part-01/>Part-I</a> of this series, where I detailed this.</em></p></blockquote><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>This concludes the implementation details of two high-level Animation APIs, which animate things on state change. While these APIs look different from others, they leverage low-level Animation APIs to hide boilerplate code that you need to write otherwise. Let&rsquo;s summarise them.</p><h3 id=animateasstate-1>animate*AsState<a hidden class=anchor aria-hidden=true href=#animateasstate-1>#</a></h3><ol><li>This is a composable wrapping <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a> and delegates animation to it.</li><li>Internally it uses channel to publish all state change and observe this channel within <code>LauchedEffect</code> to forward state changes to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animatable.kt;drc=a3f12e1332e6df5a3da7cb979733c58d8eb9364e;l=50"><code>Animatable</code></a></li></ol><h3 id=transition-1>Transition<a hidden class=anchor aria-hidden=true href=#transition-1>#</a></h3><ol><li><a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=0c832c139dc844fcc611c7b5cdb1496ba5071a3a;l=88"><code>updateTransition</code></a> composable is the entry point that internally creates a <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> object.</li><li><a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> react to state changes, start listening for frame changes, and forward them to all child animations</li><li>Child animations are wrapped in <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> object, which reacts to frame change from <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> and internally delegates animation to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Animation.kt;drc=975e20a49c9f51099ee4b8e302fd92add31e27a2;l=41"><code>Animation</code></a> API.</li><li>The updated animation values are then applied to <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=1303"><code>TransitionAnimationState</code></a> which causes recomposition</li></ol><h2 id=parting-thoughts>Parting Thoughts<a hidden class=anchor aria-hidden=true href=#parting-thoughts>#</a></h2><p>I know this is a bit heavy to digest. I would recommend reading this along with the full implementation open on <a href=cs.android.com>cs.android.com</a>.</p><p>If you are still here, you are brave! Pet yourself on the back. Honestly, I am unsure if I simplified this enough to sink this in. <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation-core/src/commonMain/kotlin/androidx/compose/animation/core/Transition.kt;drc=03da7b0f4fe28c1031276b125af612ada99e9e49;l=888"><code>Transition</code></a> animation was by far difficult to explain as it involves multiple animations and additional state objects.</p><p>With this part, I am concluding this series on the internals of Compose animation API. I hope this series was insightful. If you have any suggestions or questions, please drop them in the comment below. Until then, stay curious!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sagarviradiya.dev/tags/compose/>Compose</a></li><li><a href=https://sagarviradiya.dev/tags/animation/>Animation</a></li></ul><nav class=paginav><a class=next href=https://sagarviradiya.dev/posts/compose-animation-part-02/><span class=title>Next ¬ª</span><br><span>Compose Animation, Under The Hood - Part II</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//sagarviradiya-dev.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://sagarviradiya.dev/>Sagar's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>